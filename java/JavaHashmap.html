<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java集合 HashMap | DD</title>
  <meta name="keywords" content=" hashmap ">
  <meta name="description" content="Java集合 HashMap | DD">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="权当年轻留个纪念">
<meta property="og:type" content="website">
<meta property="og:title" content="about">
<meta property="og:url" content="http://dqw6668.github.io/about/index.html">
<meta property="og:site_name" content="DD">
<meta property="og:description" content="权当年轻留个纪念">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-06-08T09:18:38.140Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="about">
<meta name="twitter:description" content="权当年轻留个纪念">


<link rel="icon" href="/img/avatar.jpg">

<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/hl_theme/atom-light.css">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<link href="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/photoswipe/4.1.2/default-skin/default-skin.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
</div>
<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>dqw6668</span>
</div>

<div class="icon">
    
    
    <a class="github" title="github" href="https://github.com/dqw6668" target="_blank"></a>
    
    
    
    
    
    
    
    
    <a class="email" title="email" href="mailto:xss_me@qq.com"></a>
    
</div>



<ul>
    <li class="all active">全部文章</li>
    
    <li data-rel="leetcode"> leetcode </li>
    
    <li data-rel="安全"> 安全 </li>
    
    <li data-rel="杂"> 杂 </li>
    
    <li data-rel="基础"> 基础 </li>
    
    <li data-rel="python"> python </li>
    
    <li data-rel="java"> java </li>
    
    <li data-rel="设计模式"> 设计模式 </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="33">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>
    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友链
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
        <label for="tagswitch">Tags:</label>
        <input id="tagswitch" type="checkbox">
    </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">0-1bag</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">leetcode</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">DDOS</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">安全</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">测试</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">学习总结</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">LDAP</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">认证</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">TCP三次握手</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">SQL注入</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">shell</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">操作系统</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">设计模式</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">瞎想</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">红黑树</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">安全扫描工具</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">django</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color3">hashmap</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">JVM</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="leetcode "
           href="/code/LeetCode题解.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode (Java)【目录】">LeetCode (Java)【目录】</span>
            <span class="post-date" title="2018-09-27 00:00:00">2018/09/27</span>
        </a>
        
        <a  class="java "
           href="/java/JavaHashmap.html"
           data-tag="hashmap"
           data-author="" >
            <span class="post-title" title="Java集合 HashMap">Java集合 HashMap</span>
            <span class="post-date" title="2018-10-03 22:14:47">2018/10/03</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.20. 有效的括号.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.20. 有效的括号">LeetCode.20. 有效的括号</span>
            <span class="post-date" title="2018-10-03 22:10:08">2018/10/03</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.11. 盛最多水的容器.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.11. 盛最多水的容器">LeetCode.11. 盛最多水的容器</span>
            <span class="post-date" title="2018-10-03 00:31:35">2018/10/03</span>
        </a>
        
        <a  class="java "
           href="/java/深入理解JVM虚拟机第7章.html"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM-深入理解虚拟机类加载机制">JVM-深入理解虚拟机类加载机制</span>
            <span class="post-date" title="2018-10-02 23:24:03">2018/10/02</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.5. 最长回文子串.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.5. 最长回文子串">LeetCode.5. 最长回文子串</span>
            <span class="post-date" title="2018-10-02 23:14:42">2018/10/02</span>
        </a>
        
        <a  class="基础 "
           href="/interview/2-3树到红黑树.html"
           data-tag="红黑树"
           data-author="" >
            <span class="post-title" title="2-3树到红黑树">2-3树到红黑树</span>
            <span class="post-date" title="2018-09-30 13:35:11">2018/09/30</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.4. 两个排序数组的中位数.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.4. 两个排序数组的中位数">LeetCode.4. 两个排序数组的中位数</span>
            <span class="post-date" title="2018-09-30 13:31:25">2018/09/30</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.3. 无重复字符的最长子串.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.3. 无重复字符的最长子串">LeetCode.3. 无重复字符的最长子串</span>
            <span class="post-date" title="2018-09-28 01:42:10">2018/09/28</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.2. 两数相加.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.2. 两数相加">LeetCode.2. 两数相加</span>
            <span class="post-date" title="2018-09-27 15:20:10">2018/09/27</span>
        </a>
        
        <a  class="java 设计模式 "
           href="/java/设计模式/设计模式之策略模式.html"
           data-tag="java,设计模式"
           data-author="" >
            <span class="post-title" title="JAVA与模式-策略模式">JAVA与模式-策略模式</span>
            <span class="post-date" title="2018-09-27 14:44:00">2018/09/27</span>
        </a>
        
        <a  class="leetcode "
           href="/code/LeetCode.1. 两数之和.html"
           data-tag="leetcode"
           data-author="" >
            <span class="post-title" title="LeetCode.1. 两数之和">LeetCode.1. 两数之和</span>
            <span class="post-date" title="2018-09-27 14:35:10">2018/09/27</span>
        </a>
        
        <a  class="java 设计模式 "
           href="/java/设计模式/设计模式之单例模式.html"
           data-tag="java,设计模式"
           data-author="" >
            <span class="post-title" title="JAVA与模式-单例模式">JAVA与模式-单例模式</span>
            <span class="post-date" title="2018-09-25 00:00:00">2018/09/25</span>
        </a>
        
        <a  class="杂 "
           href="/all/shell脚本复习.html"
           data-tag="shell"
           data-author="" >
            <span class="post-title" title="shell命令复习">shell命令复习</span>
            <span class="post-date" title="2018-08-06 00:00:00">2018/08/06</span>
        </a>
        
        <a  class="杂 "
           href="/all/redis.html"
           data-tag="redis"
           data-author="" >
            <span class="post-title" title="认识redis">认识redis</span>
            <span class="post-date" title="2018-08-04 00:00:00">2018/08/04</span>
        </a>
        
        <a  class="安全 "
           href="/safe/LDAP.html"
           data-tag="LDAP,认证"
           data-author="" >
            <span class="post-title" title="openLDAP搭建认证与目录系统">openLDAP搭建认证与目录系统</span>
            <span class="post-date" title="2018-07-15 00:00:00">2018/07/15</span>
        </a>
        
        <a  class="安全 "
           href="/safe/SQLI.html"
           data-tag="SQL注入"
           data-author="" >
            <span class="post-title" title="自建环境玩耍SQLI">自建环境玩耍SQLI</span>
            <span class="post-date" title="2018-07-13 00:00:00">2018/07/13</span>
        </a>
        
        <a  class="python "
           href="/python/python3催钱.html"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="py微信定时消息之 欠债还钱">py微信定时消息之 欠债还钱</span>
            <span class="post-date" title="2018-06-21 00:00:00">2018/06/21</span>
        </a>
        
        <a  class="安全 "
           href="/safe/DDOS.html"
           data-tag="DDOS,安全"
           data-author="" >
            <span class="post-title" title="反射型DDoS放大攻击的原理分析和防范措施">反射型DDoS放大攻击的原理分析和防范措施</span>
            <span class="post-date" title="2018-06-19 00:00:00">2018/06/19</span>
        </a>
        
        <a  class="java "
           href="/java/maven.html"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="初识maven">初识maven</span>
            <span class="post-date" title="2018-06-04 00:00:00">2018/06/04</span>
        </a>
        
        <a  class="杂 "
           href="/all/Junit.html"
           data-tag="测试,学习总结"
           data-author="" >
            <span class="post-title" title="JUnit使用">JUnit使用</span>
            <span class="post-date" title="2018-06-01 00:00:00">2018/06/01</span>
        </a>
        
        <a  class="杂 "
           href="/all/Git-bash.html"
           data-tag="学习总结"
           data-author="" >
            <span class="post-title" title="Git使用">Git使用</span>
            <span class="post-date" title="2018-05-25 00:00:00">2018/05/25</span>
        </a>
        
        <a  class="杂 "
           href="/all/AppScan.html"
           data-tag="学习总结,安全扫描工具"
           data-author="" >
            <span class="post-title" title="AppScan使用">AppScan使用</span>
            <span class="post-date" title="2018-05-19 00:00:00">2018/05/19</span>
        </a>
        
        <a  class="python "
           href="/python/py实现基本数据结构.html"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="数据结构基础 python实现">数据结构基础 python实现</span>
            <span class="post-date" title="2018-05-03 00:00:00">2018/05/03</span>
        </a>
        
        <a  class="杂 "
           href="/all/QA.html"
           data-tag="测试,学习总结"
           data-author="" >
            <span class="post-title" title="QA职责流程">QA职责流程</span>
            <span class="post-date" title="2018-05-02 00:00:00">2018/05/02</span>
        </a>
        
        <a  class="基础 "
           href="/interview/TCP.html"
           data-tag="TCP三次握手"
           data-author="" >
            <span class="post-title" title="TCP三次和四次">TCP三次和四次</span>
            <span class="post-date" title="2018-04-29 00:00:00">2018/04/29</span>
        </a>
        
        <a  class="leetcode "
           href="/code/0-1bag.html"
           data-tag="0-1bag"
           data-author="" >
            <span class="post-title" title="0-1背包问题">0-1背包问题</span>
            <span class="post-date" title="2018-04-23 00:00:00">2018/04/23</span>
        </a>
        
        <a  class="python "
           href="/python/pychekio之home.html"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="pychekio上的练习之home">pychekio上的练习之home</span>
            <span class="post-date" title="2018-04-03 00:00:00">2018/04/03</span>
        </a>
        
        <a  class="python "
           href="/python/django创建应用源码--1.html"
           data-tag="django"
           data-author="" >
            <span class="post-title" title="django创建应用 源码1">django创建应用 源码1</span>
            <span class="post-date" title="2018-03-27 00:00:00">2018/03/27</span>
        </a>
        
        <a  class="python "
           href="/python/重建二叉树.html"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="面试题6 重建二叉树">面试题6 重建二叉树</span>
            <span class="post-date" title="2018-03-23 00:00:00">2018/03/23</span>
        </a>
        
        <a  class="python "
           href="/python/七大排序.html"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="七大经典排序算法python">七大经典排序算法python</span>
            <span class="post-date" title="2018-03-20 00:00:00">2018/03/20</span>
        </a>
        
        <a  class="杂 "
           href="/all/近期的目标.html"
           data-tag="瞎想"
           data-author="" >
            <span class="post-title" title="月底小目标">月底小目标</span>
            <span class="post-date" title="2018-03-19 00:00:00">2018/03/19</span>
        </a>
        
        <a  class="基础 "
           href="/interview/操作系统调度算法.html"
           data-tag="学习总结,操作系统"
           data-author="" >
            <span class="post-title" title="调度算法">调度算法</span>
            <span class="post-date" title="2018-01-13 00:00:00">2018/01/13</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-JavaHashmap" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java集合 HashMap</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
            <a href="javascript:" data-rel="java">java</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color3">hashmap</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2018-10-03 22:42:03'>2018-10-03 22:14</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#初识HashMap"><span class="toc-text">初识HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put方法添加元素的过程"><span class="toc-text">put方法添加元素的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get方法获取value的过程"><span class="toc-text">get方法获取value的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash函数（散列函数）的实现"><span class="toc-text">hash函数（散列函数）的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESIZE-的实现"><span class="toc-text">RESIZE 的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充"><span class="toc-text">补充</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="初识HashMap"><a href="#初识HashMap" class="headerlink" title="初识HashMap"></a>初识HashMap</h2><p>可以认为是HashMap是存放键值对的集合。 </p>
<h2 id="put方法添加元素的过程"><a href="#put方法添加元素的过程" class="headerlink" title="put方法添加元素的过程"></a>put方法添加元素的过程</h2><ol>
<li><p>对 key 的 hashCode() 做 hash 计算，然后在计算 index，index 是长度为M数组的索引； </p>
</li>
<li><p>如果没有碰撞，把该对象直接放到bucket（数组）中； </p>
</li>
<li><p>如果碰撞，则存放到以下标index的元素作为开头的链表中； </p>
</li>
<li><p>如果碰撞导致链表过长（大于等于TREEIFY_THRESHOLD），就把同一个hash值的元素所组成的链表转换成<strong>红黑树（属于 Java8 优化的部分）</strong> </p>
</li>
<li><p>如果结点已经存在，则替换掉old value（保证key的唯一性） </p>
</li>
<li><p>如果bucket的使用率超过负载因子（load factor），就要resize 加倍容量bucket/table（数组+链表）的大小。由于计算index跟容量有关，所以需要rehash所有元素，并把它们存放到这个新的bucket中。因此，HashMap不能确保元素的次序始终不变。 </p>
</li>
</ol>
<p><strong>put源码如下</strong></p>
<pre><code>public V put(K key, V value) {
    // 对key的hashCode()做hash
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // tab为空，也即是table中还没有元素，则创建一个默认长度为16的table数组
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 计算index，如果该索引处为null，也即没有hash碰撞时，直接把元素存储起来即可
    // 计算索引的方法 i = (n - 1) &amp; hash，它跟table数组的长度是紧密相关的，
    // 所以当table的长度发生变化时，需要重新计算所有元素的索引 
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {  // 如果该索引（下标）处不为空，也即是存在元素，则分以下若干种情况处理
        Node&lt;K,V&gt; e; K k;
        // 情况一：如果两者的hash值相等，且它们的键相等时，更新该元素
        // 键相等判断，首先判断hashCode（或者hash值），hashCode相等且它们的key的值也相等，则更新该元素
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 情况二：hashCode不相等或者hashCode相等但是key值（也即equals）不相等时，需要插入该元素
        // 情况二：1，如果该链为树，则将该元素插入到红黑树中
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 情况二：2，如果该链为链表，则将该元素插入到链表中
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // 写入......
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 超过load factor*current capacity，resize，
    // 也即是table数组的使用率超过装载因子，需要扩大一倍table的容量
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre><h2 id="get方法获取value的过程"><a href="#get方法获取value的过程" class="headerlink" title="get方法获取value的过程"></a>get方法获取value的过程</h2><ol>
<li><p>和put方法一样，首先计算index，如果bucket为null，则返回null </p>
</li>
<li><p>如果bucket中只有一个元素，则直接命中，取出value即可 </p>
</li>
<li><p>如果碰撞，则通过key.equals(k)查找对应的entry（Node）<br> 如果是链表，则遍历链表，通过key.equals(k)判断是否命中，时间复杂度是 O(n)<br> 如果是红黑树，则查找的时间复杂度是 O(lgn) </p>
</li>
</ol>
<p><strong>get方法源码如下</strong></p>
<pre><code>   final Node&lt;K,V&gt; getNode(int hash, Object key) {
       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
       if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
           (first = tab[(n - 1) &amp; hash]) != null) {  // 如果第一个元素为null，则返回null
        // table中的某一bucket中存在跟当前key相等的结点
        // 如果在bucket的第一个元素命中，则直接返回第一个元素
           if (first.hash == hash &amp;&amp; // always check first node
               ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
               return first;
           // 如果跟bucket中的第一个元素不相等，则跟后面的元素对比
           if ((e = first.next) != null) {
            // 如果解决碰撞（冲突）的方式的红黑树，则在红黑树中查找
               if (first instanceof TreeNode)
                   return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
               do {  // 如果解决碰撞的方式是链表，则在链表中线性遍历查找
                   if (e.hash == hash &amp;&amp;
                       ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                       return e;
               } while ((e = e.next) != null);
           }
       }
       return null;
   }
</code></pre><h2 id="hash函数（散列函数）的实现"><a href="#hash函数（散列函数）的实现" class="headerlink" title="hash函数（散列函数）的实现"></a>hash函数（散列函数）的实现</h2><p>key的hashCode()和table数组的长度作为计算hash值的参数。<br> 计算过程是， </p>
<ol>
<li>将hashCode的前16位和后16为做异或运算（两个数字做异或运算，有一个1则结果为1）</li>
</ol>
<p>计算索引是在计算hash值的基础上，将上面结果跟数组长度-1做按位与运算（按位与运算，有两个1则结果为1），这样结果一定位于[0, length)之间。</p>
<p><strong>hash函数源码如下：</strong></p>
<pre><code>static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>代码注释给出第一步的解释如下：<br> Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.  Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.)  So we apply a transform that spreads the impact of higher bits downward. There is a <strong>tradeoff between speed, utility, and quality of bit-spreading</strong>. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we <strong>use trees to handle large sets of collisions in bins</strong>, we <strong>just XOR some shifted bits in the cheapest possible way to reduce systematic lossage</strong>, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p>
<p>在设计hash函数时，因为table的长度n为2的幂，所以是hashCode的前16位和后16位按位与运算，而不是整数除留余数法（%n）。<strong>这种做法将在resize函数中发挥着极为重要的作用。</strong></p>
<p>在Java 8 之前的实现中，使用链表解决冲突的，在产生碰撞的情况下，进行get操作的时间复杂度是O(1)+O(n)。因此，当碰撞较严重，也就是n较大时将严重地影响查找速度。</p>
<p>Java 8 改进了这一点，当链表长度超过 TREEIFY_THRESHOLD时，将链表中的元素构建为一棵红黑树，这样时间复杂度降低为 O(1)+O(logn)。</p>
<h2 id="RESIZE-的实现"><a href="#RESIZE-的实现" class="headerlink" title="RESIZE 的实现"></a>RESIZE 的实现</h2><p>进行put操作后，如果发现table数组的利用率超过了装载因子（Load Factor），就会将table的容量扩充为原来的2倍，之后重新计算各个元素的index，并将它们插入到新的table中。</p>
<p>resize函数上的注释为：<br> nitializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must <strong> either stay at same index, or move with a power of two offset \</strong> in the new table.</p>
<p>也即是，当table容量扩展为原来的2倍后，元素的index要么跟原来一样，要么在原位置的基础上移动2次幂的位置。</p>
<p>怎么理解呢？<br> 例如table容量从16扩展为32时，各个元素key 的hash值（hashCode的前16位和后16位按位与操作的结果）的每一位数字要么是0要么是1，它们是不变的。<br> 而 index = hash*（n-1），n加倍了，相当于n-1的最高位与hash值中对应位置上的数字按位与得到一个结果 x，将这个x与没扩容前的index求和就得到了该元素在新table中的index。</p>
<p><strong>注：n-1 = power(2, m) - 1，把它转换成二进制，32位的二进制中各个低位都为1，各个高位都为0。</strong></p>
<p>这个计算index的设计十分巧妙， 既省去了重新计算hash值，而且同时，由于新增的1 bit是0还是1可以认为是随机的，因此resize的过程，均匀地把之前冲突的结点分散到新的bucket了。</p>
<p><strong>resize的源码如下：</strong></p>
<pre><code>final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) {
        // 超过table的最大容量就不再扩充，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    }
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 计算新的resize上限
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原索引+oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>什么时候会使用HashMap？它有什么特点？</p>
<blockquote>
<p>是基于Map接口的实现，HashMap存储Map.Entry(hash, key, value, next)对象。<br>   特点一， 存储键值对时，它可以接受null的键和值（由于Map中的键是唯一的，所以最多只有一个键为 null 的键值对）；<br>   特点二，它是非同步的。</p>
</blockquote>
</li>
<li><p>HashMap的工作原理<br> HashMap最为重要的两个操作是 put（插入或更新对象） 和 get（根据键获取对象）。</p>
<blockquote>
<p>put，存储或者更新对象时，将K/V传递给put方法，put会先调用hash函数计算key的hash值，然后结合table容量计算index，然后将该键值对插入或者更新；<br>   如果产生碰撞，当碰撞元素个数小于TREEIFY_THRESHOLD阈值时，将元素放置在链表末尾，也就是使用链表解决碰撞问题；当碰撞元素个数大于等于TREEIFY_THRESHOLD阈值时，将链表中的元素创建一棵红黑树；<br>   如果HashMap的table使用率超过装载因子（load factor），它将调用resize函数，将table的容量增大一倍（扩展为原来的2倍），然后，根据原来table中每个元素的hash值（不需要重复计算，Entry包含这个属性，hash, key, value, next）和table的新容量n-1 重新计算它们在新table中的位置。</p>
<p>get，获取对象时，将K传递给get方法，get会调用hashCode方法，然后通过hash散列函数计算出hash值，结合table容量n-1计算出index，进一步调用equals方法确定键值对。</p>
</blockquote>
</li>
<li><p>你知道put和get的原理吗，hashCode()和equals()都有什么作用吗？</p>
<blockquote>
<p>在put或get操作时，通过key的hashCode进行计算hash值（hashCode的高16位和低16位进行按位异或操作的结果），然后根据HashMap的容量n计算index（index=（n-1）&amp;hash）。<br>   如果产生碰撞，则使用key.equals()方法去链表或者平衡树中查找对应的键值对。</p>
<p>讨论一下键值对是否能够成功插入到HashMap中：<br>   (1) 如果hashCode是唯一的，则一定可以插入（不考虑极端情况，比如内存不足等因素）；<br>   (2) 如果hashCode值在HashMap中出现过，且它们两者调用equals返回true，则更新键值对；<br>   (3)如果hashCode值在HashMap中出现过，且它们两者调用equals返回false，则产生碰撞，将该键值对插入到链表或者平衡树中；<br>   （hashCode是定位的，存储位置；equals是定性的，比较两者是否相等）</p>
<p>建议：<br>   重写hashCode和equals两个方法结果的一致性。<br>   当元素插入到HashMap之后，不要修改影响hashCode结果的成员变量，否则，不能保证key的唯一性。<br>   最好使用不可变对象作为key。</p>
</blockquote>
</li>
<li><p>你知道hash的实现吗？为什么要这样实现？</p>
<blockquote>
<p>在Java8的实现中，是通过将hashCode结果的高16位和低16位按位异或计算出来的，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)。<br>   主要是从速度、功效、质量考虑的，这么做可以在table的n较小的时候，也能保证高低位都参与到hash的计算中，同时不会有太大的开销。<br>   而且，这个计算是一次性的，当resize时，也不需要重新计算hash值。</p>
</blockquote>
</li>
<li><p>如果HashMap的大小超过了装载因子（load factor）定义的容量，怎么办？</p>
<blockquote>
<p>如果table容量的使用率等于大于装载因子（默认是0.75）时，则会调用resize方法产生一个原来大小两倍的table，并且重新计算每个元素的index（不必重新计算hash方法，因为根据定义每次计算的结构都是一样的，不过得把这个值保存起来，Entry(hash, key, value, next)）<br>   注：各种集合的默认参数<br>   HashMap，默认容量是16，装载因子是 0.75<br>   ArrayList，默认长度是 10</p>
</blockquote>
</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li><p>桶数组长度取2的次方的直接原因：将取模运算优化为做和length-1的与运算，并在此情况下，因为length-1二进制位全为1，求index的结果会等同于hashcode的后n位，也就是可以认为，只要hashcode本身是均匀的，那么hash算法结果也是均匀的。 要点：不是为了减少碰撞把长度取为2的次方，==如果要用与运算，一定要是2的n次方==，如果是为了减少碰撞，那么取素数才是最有效的。这里主要是运算的优化</p>
</li>
<li><p>关于JDK1.7put头插法，扩容头插法，1.8put尾插法，尾插法让resize后链表不发生反转**，</p>
<ul>
<li><p>链表的反转问题，头插改为尾插</p>
<ul>
<li><p>先说扩容：1.7扩容，对原来的链表从第一个节点开始取，这里以a-&gt;b-&gt;c-&gt;null为例子，不管1.7，1.8取节点都是从头开始取往后遍历，这个是不会变的，那么1.7的操作是，取出a，做rehash，头插到新数组，这时新数组为a-&gt;null，接下来取b头插到新数组，假设abc都rehash后还是同样的index，那么变成b-&gt;a-&gt;null，取c变成c-&gt;b-&gt;a-&gt;null，所以1.7中每一次扩容都会发生链表反转，看源码</p>
<pre><code>//JDK1.7
void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
　　　　　　　　　 //将当前取到的entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。
                //关键的代码就是下面三行
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
</code></pre></li>
<li><p>而在1.8中，因为扩容后原链表上的Node可能会分成两部分，通过用了两条新链表：一条loHead下标为index，一条hiHead下标为index+Oldcap，通过遍历所有的原链表中的节点，同样a-&gt;b-&gt;c-&gt;null，这里假设b的index和ac不同，那么首先a，通过1.8的巧运算（遗弃了rehash，后面说）通过尾插法变成loHead-&gt;a-&gt;null,取b后变成hiHead-&gt;b-&gt;null，取c后变成loHead-&gt;a-&gt;c-&gt;null，这时遍历完成，将两条新链表接到新数组对应的index上。源码看关键部分40行到69行</p>
</li>
<li><pre><code>//JDK1.8
final Node&lt;K,V&gt;[] resize() {
        Node&lt;K,V&gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &lt;&lt; 1; // double threshold
        }
        else if (oldThr &gt; 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                 //这里开始，把节点巧运算后分到两条链表
                    else { // preserve order
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        do {
                            next = e.next;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                   //直到原链表全部Node取完，分别把两条链表放到新数组
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
              //-------------------------------------------------
                        }
                    }
                }
            }
        }
        return newTab;
    }
</code></pre><p>同时，因为这一部分（取出了40-60行），两个链表依次在末端添加节点，在多线程下，第二个线程无非重复第一个线程一模一样的操作，解决了多线程Put导致的死循环。但仍然不安全。</p>
</li>
</ul>
</li>
<li><p>关于1.8中舍弃rehash使用的巧运算。既对hash在新增的bit位看为0还是为1，1.7的rehash是对扩容后的length做length-1的与操作，1.8是对e.hash &amp; oldCap这样的与操作</p>
<ul>
<li>并没有提升量级时间性能！不过减少了代码量。也减少了运算（原来rehash肯定步骤多）。</li>
<li>还有的说1.8对一个位的bit取与操作，让原一个链表的节点均匀分为0或1，这是1.8的优化，想一想，1.8的操作和1.7对length-1与操作的结果，没有任何改变，一模一样的，1.8的运算就是对&amp; length-1的一个转换方式罢了。原来是1.7是a <em> c+b </em> c，现在写为(a + b) * c，结果变没变？ 我看来，不过是写JDK的人取了个巧罢了。</li>
</ul>
</li>
<li><p>关于1.7中PUT用头插法，因为插入链表的时候已经遍历了一遍链表了，并不是说头插比尾插更效率，只要插入都要摸链，那么既然都摸到链表尾了，还使用头插？这里想想操作系统的某些调度算法，是不是有一种，刚用过的数据极大可能马上再用？【最近最久未使用】。这是时间局部性原理。</p>
</li>
</ul>
</li>
</ol>

      
       <hr><span style="font-style: italic;color: gray;"> PHP是世界上最好的语言 </span>
    </div>
</article>






    

    </div>

    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

</body>
<script src="//cdn.bootcss.com/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script src="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe-ui-default.min.js"></script>

<script src="/js/script.js"></script>
<script>
    var img_resize = 'photoSwipe';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#0-1bag','#leetcode','#DDOS','#安全','#测试','#学习总结','#LDAP','#认证','#TCP三次握手','#SQL注入','#python','#java','#shell','#redis','#操作系统','#设计模式','#瞎想','#红黑树','#安全扫描工具','#django','#hashmap','#JVM',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1;
            var $numbering = $('<ul/>').addClass('pre-numbering').attr("unselectable","on");
            $(this).addClass('has-numbering')
                    .parent()
                    .append($numbering);
            for(i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        

        // PhotoSwipe
        $('article').each(function(i){
            $(this).find('img').each(function(){
                if ($(this).closest('figure').hasClass('article-gallery-img')) {
                    return;
                }
                var alt = this.alt;
                $(this)
                    .wrap('<figure class="article-gallery-img" itemprop="associatedMedia" itemscope itemtype="http://schema.org/ImageObject"></figure>')
                    .wrap('<a href="' + this.src + '" title="' + alt + '"></a>');
                $(this).after('<div class="img_alt"><span>' + (alt || '') + '</span></div>');
            });
        });

        var pswpElement = document.querySelectorAll('.pswp')[0];
        if (pswpElement) {
            var gallerySelector = '.article-gallery, article';

            var initPhotoSwipeFromDOM = function(gallerySelector) {

                // parse slide data (url, title, size ...) from DOM elements
                // (children of gallerySelector)
                var parseThumbnailElements = function(el) {
                    var thumbElements = $(el).find('figure.article-gallery-img').toArray(),
                        numNodes = thumbElements.length,
                        items = [],
                        figureEl,
                        linkEl,
                        size,
                        imgEl,
                        item;

                    for (var i = 0; i < numNodes; i++) {

                        figureEl = thumbElements[i]; // <figure> element

                        // include only element nodes
                        if (figureEl.nodeType !== 1) {
                            continue;
                        }

                        linkEl = figureEl.children[0]; // <a> element
                        imgEl = linkEl.children[0]; // <img>

                        size = linkEl.getAttribute('data-size');
                        size = size && size.split('x');

                        // create slide object
                        item = {
                            src: linkEl.getAttribute('href'),
                            w: size && parseInt(size[0], 10) || imgEl.width,
                            h: size && parseInt(size[1], 10) || imgEl.height
                        };

                        if (figureEl.children.length > 1) {
                            // <figcaption> content
                            item.title = figureEl.children[1].innerHTML;
                        }

                        if (linkEl.children.length > 0) {
                            // <img> thumbnail element, retrieving thumbnail url
                            item.msrc = linkEl.children[0].getAttribute('src');
                        }

                        item.el = figureEl; // save link to element for getThumbBoundsFn
                        items.push(item);
                    }

                    return items;
                };

                // find nearest parent element
                var closest = function closest(el, fn) {
                    return el && (fn(el) ? el : closest(el.parentNode, fn));
                };

                // triggers when user clicks on thumbnail
                var onThumbnailsClick = function(e) {
                    e = e || window.event;

                    var eTarget = e.target || e.srcElement;

                    // find root element of slide
                    var clickedListItem = closest(eTarget, function(el) {
                        return (el.tagName && el.tagName.toUpperCase() === 'FIGURE');
                    });

                    if (!clickedListItem) {
                        return;
                    }

                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }

                    // find index of clicked item by looping through all child nodes
                    // alternatively, you may define index via data- attribute
                    var clickedGallery = $(clickedListItem).closest(gallerySelector)[0],
                        childNodes = $(clickedGallery).find('figure.article-gallery-img').toArray(),
                        numChildNodes = childNodes.length,
                        nodeIndex = 0,
                        index;

                    for (var i = 0; i < numChildNodes; i++) {
                        if (childNodes[i].nodeType !== 1) {
                            continue;
                        }

                        if (childNodes[i] === clickedListItem) {
                            index = nodeIndex;
                            break;
                        }
                        nodeIndex++;
                    }



                    if (index >= 0) {
                        // open PhotoSwipe if valid index found
                        openPhotoSwipe(index, clickedGallery);
                    }
                    return false;
                };

                // parse picture index and gallery index from URL (#&pid=1&gid=2)
                var photoswipeParseHash = function() {
                    var hash = window.location.hash.substring(1),
                        params = {};

                    if (hash.length < 5) {
                        return params;
                    }

                    var vars = hash.split('&');
                    for (var i = 0; i < vars.length; i++) {
                        if (!vars[i]) {
                            continue;
                        }
                        var pair = vars[i].split('=');
                        if (pair.length < 2) {
                            continue;
                        }
                        params[pair[0]] = pair[1];
                    }

                    if (params.gid) {
                        params.gid = parseInt(params.gid, 10);
                    }

                    return params;
                };

                var openPhotoSwipe = function(index, galleryElement, disableAnimation, fromURL) {
                    var pswpElement = document.querySelectorAll('.pswp')[0],
                        gallery,
                        options,
                        items;

                    items = parseThumbnailElements(galleryElement);

                    // define options (if needed)
                    options = {

                        // define gallery index (for URL)
                        galleryUID: galleryElement.getAttribute('data-pswp-uid'),

                        getThumbBoundsFn: function(index) {
                            // See Options -> getThumbBoundsFn section of documentation for more info
                            var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail
                                pageYScroll = window.pageYOffset || document.documentElement.scrollTop,
                                rect = thumbnail.getBoundingClientRect();

                            return {
                                x: rect.left,
                                y: rect.top + pageYScroll,
                                w: rect.width
                            };
                        }
                    };

                    // PhotoSwipe opened from URL
                    if (fromURL) {
                        if (options.galleryPIDs) {
                            // parse real index when custom PIDs are used
                            // http://photoswipe.com/documentation/faq.html#custom-pid-in-url
                            for (var j = 0; j < items.length; j++) {
                                if (items[j].pid == index) {
                                    options.index = j;
                                    break;
                                }
                            }
                        } else {
                            // in URL indexes start from 1
                            options.index = parseInt(index, 10) - 1;
                        }
                    } else {
                        options.index = parseInt(index, 10);
                    }

                    // exit if index not found
                    if (isNaN(options.index)) {
                        return;
                    }

                    if (disableAnimation) {
                        options.showAnimationDuration = 0;
                    }

                    // Pass data to PhotoSwipe and initialize it
                    gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);

                    gallery.listen('imageLoadComplete', function(index, item) {
                        var linkEl = item.el.children[0];
                        var img = item.container.children[0];
                        if (!linkEl.getAttribute('data-size')) {
                            linkEl.setAttribute('data-size', img.naturalWidth + 'x' + img.naturalHeight);
                            item.w = img.naturalWidth;
                            item.h = img.naturalHeight;
                            gallery.invalidateCurrItems();
                            gallery.updateSize(true);
                        }
                    });

                    gallery.init();
                };

                // loop through all gallery elements and bind events
                var galleryElements = document.querySelectorAll(gallerySelector);

                for (var i = 0, l = galleryElements.length; i < l; i++) {
                    galleryElements[i].setAttribute('data-pswp-uid', i + 1);
                    galleryElements[i].onclick = onThumbnailsClick;
                }

                // Parse URL and open gallery if it contains #&pid=3&gid=1
                var hashData = photoswipeParseHash();
                if (hashData.pid && hashData.gid) {
                    openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true);
                }
            };

            // execute above function
            initPhotoSwipeFromDOM(gallerySelector);
        }
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 2px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
</style>

<!--自定义样式设置-->
<style>
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 2px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /*引用块样式*/
    
    .post .pjax article blockquote {
        padding: 10px 20px;
        background-color: white;
        border: none;
        border-left: 4px solid #42b983;
        border-right: 4px solid #42b983;
        border-radius: 10px;
    }
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.1;
        background: url("/img/12.webp");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    
</style>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element, as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. PhotoSwipe keeps only 3 slides in DOM to save memory. -->
        <!-- don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>





</html>
